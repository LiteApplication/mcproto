- Changed the way `Serializable` classes are handled:

  Here is how a basic `Serializable` class looks like:

  ```python
    @final
    @dataclass
    class ToyClass(Serializable):
        """Toy class for testing demonstrating the use of gen_serializable_test on `Serializable`."""

        a: int
        b: str | int

        @override
        def __attrs_post_init__(self):
            """Initialize the object."""
            if isinstance(self.b, int):
                self.b = str(self.b)

            super().__attrs_post_init__() # This will call validate()

        @override
        def serialize_to(self, buf: Buffer):
            """Write the object to a buffer."""
            self.b = cast(str, self.b)  # Handled by the __attrs_post_init__ method
            buf.write_varint(self.a)
            buf.write_utf(self.b)

        @classmethod
        @override
        def deserialize(cls, buf: Buffer) -> ToyClass:
            """Deserialize the object from a buffer."""
            a = buf.read_varint()
            if a == 0:
                raise ZeroDivisionError("a must be non-zero")
            b = buf.read_utf()
            return cls(a, b)

        @override
        def validate(self) -> None:
            """Validate the object's attributes."""
            if self.a == 0:
                raise ZeroDivisionError("a must be non-zero")
            if len(self.b) > 10:
                raise ValueError("b must be less than 10 characters")

  ```

The `Serializable` class implement the following methods:

  - `serialize_to(buf: Buffer) -> None`: Serializes the object to a buffer.
  - `deserialize(buf: Buffer) -> Serializable`: Deserializes the object from a buffer.

  And the following optional methods:

  - `validate() -> None`: Validates the object's attributes, raising an exception if they are invalid.
  - `__attrs_post_init__() -> None`: Initializes the object. Call `super().__attrs_post_init__()` to validate the object.
